\documentclass{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[russian]{babel}

% Set page size and margins
% Replace `letterpaper' with `a4paper' for UK/EU standard size
\usepackage[letterpaper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{amsmath}
\usepackage{tocvsec2}
\usepackage{indentfirst}
\usepackage[pdftex]{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}

\begin{document}
\newpage
\setcounter{page}{1}
\begin{center}
    \textcolor{blue}{\section*{Задача 35.2 Симпатичные узоры}\addcontentsline{toc}{section}{Симпатичные узоры 35.2}}
\end{center}

\par Имя входного файла: input.txt
\par Имя выходного файла: output.txt
\par Ограничение по времени: $1$ с
\par Ограничение по памяти: нет
\\

Компания Broken Tiles известна в мире как наилучшая компания по производству различных маленьких плиток. Может показаться странным такое занятие компании, но в последнее время у очень богатых людей появилось увлечении в собирании плиток различной формы и размеров. Вот и сейчас, очень известный бизнесмен заказал новую партию плиток (чёрного и белого цвета). Из них он хочет сложить прямоугольную фигуру, но такую, чтобы в ней не было квадрата $2 \times 2$, состоящего из плиток одного цвета — такая фигура называется симпатичной.

\begin{figure}[h]
    \begin{center}
        \begin{minipage}[h]{0.45\linewidth}
            \includegraphics[width=7cm]{pattern1.png}
            \caption{\label{fig:pattern1} симпатичные фигуры}
            \label{fig:pattern1}
        \end{minipage}
        \hfill
        \begin{minipage}[h]{0.45\linewidth}
            \includegraphics[width=7cm]{pattern2.png}
            \caption{\label{fig:pattern2} несимпатичные фигуры}
            \label{fig:pattern2}
        \end{minipage}
    \end{center}
\end{figure}

Так как собирание фигур стало очень популярным, то директор компании решил узнать, сколько различных симпатичных фигур размера $n \times m$ плиток, можно сложить, используя только чёрные и белые плиток. И эту задачу он поручил Вам.
\\

\textcolor{blue}{Формат входных данных}

\noindentЕдинственная строка содержит два числа n и m $(1 \le n \le 10^{100},1 \le m \le 5)$.
\\

\textcolor{blue}{Формат выходных данных}

\noindentВыведите число различных симпатичных фигур размером $n \times m$, взятое по модулю $10000$.
\\

\par\textcolor{blue}{Примеры}

\begin{figure}[htp]
    \centering
    \includegraphics[width=1\linewidth]{examples.png}
    \label{fig:examples}
\end{figure}

\newpage
\setcounter{page}{2}
\section*{Разбор задачи}\addcontentsline{toc}{section}{Разбор задачи}

\par Начнем решать задачу как обычную задачу на динамическое программирование. Заметим, что каждая клеткая таблицы может быть только в двух состояниях: белом, обозначим его через $0$, и черном, обозначим его через $1$. Из ограничений к задаче можно понять, что длина минимальной из сторон не превысит $5$. В дальнейшем будем называть её столбцом.

\parЕсли в таблице всего один столбец, то он может быть заполнен произвольным образом и ответ на задачу в этом случае будет $m^2$.

\parКаждый столбец кодируется 5 битами (состояниями 0 или 1), поэтому может иметь $2^5$ состояний. В дальнейшем будем называть число, которым кодируется столбец, профилем. Рассмотрим ситуацию, когда все столбцы от $1$ до $k - 1$ уже полностью корректно заполнены, а столбец с номером $k - 1$ имеет профиль равный числу $m$.

\begin{figure}[htp]
    \centering
    \includegraphics[width=6cm]{table.png}
    \caption{\label{fig:table} таблица профилей (желтые столбцы заполнены корректно относительно друг друга)}
    \label{fig:table}
\end{figure}

\parНа рисунке \textcolor{blue}{рис.}\ref{fig:table} последний столбец имеет профиль $00110_2$ или $6_{10}$. Покажем совместимые с ним профили, которые при расположении столбцов рядом не образуют квадрат $2 \times 2$ одного цвета. Такими профилями будут $10000_2, 01000_2, 11000_2, 10100_2, 10010_2, 10001_2, 01100_2, 01010_2, 01001_2$, $11100_2, 11010_2, 11001_2, 10011_2, 01011_2, 01101_2, 10101_2, 11101_2, 11011_2$.

\begin{figure}[htp]
    \vspace{}
    \centering
    \includegraphics[width=1\linewidth]{profiles.png}
    \caption{\label{fig:profiles} профили совместимые с профилем $00110_2$}
    \label{fig:profiles}
\end{figure}

\parТаким образом, если имеется корректная таблица из $k - 1$ столбца, оканчивающаяся профилем $00110_2$, можно получить таблицы длиной $k$, имеющие в качестве профиля одно из 18 совместимых с $00110_2$ чисел. При этом для каждой длины таблицы и ее профиля можно хранить то количество вариантов, при помощи которых можно составить такую корректную таблицу. И при каждом переходе суммировать для таблицы с длиной $k$ и профилем $p$ все значения таблицы с длиной $k - 1$ и профилем, совместимым с $p$. Тогда получим формулу:

\[F[k][p] = \sum_{L}^{2^m} F[k - 1][l] \times g(p, l)\]

\parГде $k$ --- длина таблицы, $p$ --- интересующий нас профиль, $m$ --- высота столбца, $l$ --- профиль предыдущего столбца, а функция $g(p, l)$ возвращает $1$, если столбцы $p$ и $l$ совместимы, и $0$ в противном случае. База получивщегося рекуррентного соотношения состоит в следующем: для любого профиля, при $k$ = 1, количество вариантов раскраски клеток равно единице.

\parФункцию $g(p, l)$ можно заменить предварительно вычисленной матрицей, чтобы не вызывать проверку на совместимость профилей много раз. При этом считать совместимость профилей удобнее и быстрее с использованием битовых операций.

\parТаким образом, мы получили алгоритм построения решения, асимптотическая сложность которого составит  $O(n \times (2^m)^2)$. Такой алгоритм нас не устроит, так как он линейно зависит от $n$ и, скорее всего, вызовет превышение ограничения по времени, при $n = 10^{100}$.

\parВоспользуемся методом решения задачи, похожим на поиск чисел Фибоначчи за $O(logN)$. Создадим таблицу совместимости профилей $G$ размера $2^m \times 2^m$. Приведем пример такой таблицы для $m = 3$: 

\begin{center}
    \begin{pmatrix}
        0& 0& 1& 1& 0& 1& 1& 1\\
        0& 0& 1& 1& 1& 1& 1& 1\\
        1& 1& 1& 1& 1& 1& 1& 1\\
        1& 1& 1& 0& 1& 1& 1& 0\\
        0& 1& 1& 1& 0& 1& 1& 1\\
        1& 1& 1& 1& 1& 1& 1& 1\\
        1& 1& 1& 0& 1& 1& 0& 0\\
        1& 1& 1& 1& 1& 1& 0& 0\\
    \end{pmatrix}
\end{center}

\parЕдиница на пересечении $i-$ой строки и $j-$го столбца обозначает, что переход от профиля $i$ к профилю $j$ возможен. Если мы просуммируем значения всех ячеек этой матрицы, то получим количество вариантов расположения плиток на прямоугольнике $3 \times 3$. Из линейного алгоритма переход от одного профиля к другому выполняется по формуле: 

\[F[k][p] = \sum_{L}^{2^m} F[k - 1][L] \times G(p, l)\]

\parЗаметим, что для некоторого профиля мы перебираем все другие профили и суммируем количество вариантов, если они совместимы (и нули, если они не совместимы). Похожие действия мы делаем при перемножении матриц. И действительно, возведем матрицу $G$ в квадрат. При этом мы будем идти от профиля $i$ в профиль $j$ через всевозможные профили, то есть мы переберем все $k$ и, если возможны переходы из $i$ в $k$ и из $k$ в $j$, увеличиваем количество вариантов попадания из $i$ в $j$ за два шага на $1$. Таким образом, сумма элементов матрицы $G^2$ будет равна ответу для задачи при $n = 3$. Аналогично можно делать переход не через один, а через несколько шагов. То есть сумма элементов матрицы $G^{n - 1}$ будет равна ответу на задачу длины $n$.

\newpage
\setcounter{page}{4}
\section*{Дополнение}\addcontentsline{toc}{section}{Дополнение}
\parТак как при решении задачи мы имеем дело с очень большими числами до $10^{100}$, то нам необходимо реализовать свой класс для выполнения действий над такими числами. 
\parДля ускорения программы можно воспользоваться быстрым возведением в степень, так как оно применимо для любых объектов допускающих умножение. 
\parТакже мы можем использовать прием, который ускорит нашу программу в несколько раз. При умножении двух матриц, мы сначала транспонируем первую, а потом будем непосредственно их перемножать. Прием заключается в том, что при перемножении матриц мы берем строку одной матрицы и столбец другой и осуществляем к ним последовательный доступ. В памяти компьютера многомерные массивы разворачиваются в одномерные, и доступ к строке идет довольно быстро, за счет оптиматизаций компилятора при подсчете адресных выражений и кэширования (все данные лежат рядом и автоматически попадают в кэш). В случае со столбцом, адресное выражение (положение элемента в физической памяти компьютера) приходится вычислять заново и данные не попадают в кэш.
\parТак как в итоге нам нужно найти сумму элементов квадратной матрицы, мы можем найти сумму верхнего (нижнего) треугольника нашей матрицы, умножить на два и прибавить сумму диагональных элементов. Это также позволит нам сэкономить время.
\end{document}